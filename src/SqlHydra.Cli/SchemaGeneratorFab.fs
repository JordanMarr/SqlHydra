module SqlHydra.SchemaGeneratorFab

open Domain

open FSharp.Compiler.SyntaxTree
open FSharp.Compiler.XmlDoc
open FsAst
open Fantomas
open Domain
open System.Data
open SqlHydra.SchemaFilters

open Fantomas.Core
open Fantomas.Core.SyntaxOak
open Fantomas.FCS.Text

open Fabulous.AST
open type Ast

let range0 = range.Zero


/// Generates the outer module and table records.
let generateModule (cfg: Config) (app: AppInfo) (db: Schema) = 
    let filteredTables = 
        db.Tables 
        |> List.sortBy (fun tbl -> tbl.Schema, tbl.Name)

    let schemas = 
        let enumSchemas = db.Enums |> List.map (fun e -> e.Schema)
        let tableSchemas = filteredTables |> List.map (fun t -> t.Schema) 
        enumSchemas @ tableSchemas |> List.distinct
    
    Namespace(cfg.Namespace) {
        for schema in schemas do
            let tables = 
                filteredTables 
                |> List.filter (fun t -> t.Schema = schema)
                |> List.map (fun t -> t.Name)

            let enums = 
                db.Enums 
                |> List.filter (fun e -> e.Schema = schema)
                |> List.map (fun e -> e.Name)

            NestedModule(schema) {
                //for enum in enums do
                //    let enumType = 
                //        db.Enums 
                //        |> List.find (fun e -> e.Schema = schema && e.Name = enum)

                //    let enumValues = 
                //        enumType.Values 
                //        |> List.map (fun v -> v.Name)

                //    Type(enum) {
                //        Enum(enumValues)
                //    }

                for table in tables do
                    let tableType = 
                        db.Tables 
                        |> List.find (fun t -> t.Schema = schema && t.Name = table)

                    Record(table) {
                        for column in tableType.Columns do 
                            //Field(LongIdent($"``{column.Name}``: {column.TypeMapping.ClrType}"))
                            let fieldType = Type.LongIdent(IdentListNode([IdentifierOrDot.Ident(SingleTextNode(column.TypeMapping.ClrType, range0))], range0))
                            //let name = MultipleTextsNode([SingleTextNode(column.Name, range0); SingleTextNode(": ", range0)], range0)
                            //let field = FieldNode(None, None, Some name, false, None, None, fieldType, range.Zero)
                            let field = FieldNode(None, None,  None, false, None, Some (SingleTextNode(column.Name, range0)), fieldType, range.Zero)
                            field
                            // TODO: column.Name needs to handle spaces.
                            //Field(column.Name, column.TypeMapping.ClrType)


                    }
            }
    }

open Fantomas
open Fantomas.Core

/// Formats the generated code using Fantomas.
let toFormattedCode (cfg: Config) (app: AppInfo) (version: string) (source: WidgetBuilder<SyntaxOak.Oak>) = 
    //let comment = $"// This code was generated by `{app.Name}` -- v{version}."

    //let cfg = 
    //    { FormatConfig.FormatConfig.Default with 
    //        StrictMode = true
    //        MaxIfThenElseShortWidth = 400   // Forces ReadIfNotNull if/then to be on a single line
    //        MaxValueBindingWidth = 400      // Ensure reader property/column bindings stay on one line
    //        MaxLineLength = 400             // Ensure reader property/column bindings stay on one line
    //    }

    let output = 
        source
        |> Gen.mkOak
        |> CodeFormatter.FormatOakAsync
        |> Async.RunSynchronously

    let formattedCodeWithComment =
        [   
            output
        ]
        |> String.concat System.Environment.NewLine

    formattedCodeWithComment
