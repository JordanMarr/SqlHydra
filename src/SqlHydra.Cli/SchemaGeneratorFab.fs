module SqlHydra.SchemaGeneratorFab

open Domain

open FSharp.Compiler.SyntaxTree
open FSharp.Compiler.XmlDoc
open FsAst
open Fantomas
open Domain
open System.Data
open SqlHydra.SchemaFilters

open Fantomas.Core
open Fantomas.Core.SyntaxOak
open Fantomas.FCS.Text

open Fabulous.AST
open type Ast

let range0 = range.Zero

let backticks = Fantomas.FCS.Syntax.PrettyNaming.NormalizeIdentifierBackticks

/// Generates the outer module and table records.
let generateModule (cfg: Config) (app: AppInfo) (db: Schema) = 
    let filteredTables = 
        db.Tables 
        |> List.sortBy (fun tbl -> tbl.Schema, tbl.Name)

    let schemas = 
        let enumSchemas = db.Enums |> List.map (fun e -> e.Schema)
        let tableSchemas = filteredTables |> List.map (fun t -> t.Schema) 
        enumSchemas @ tableSchemas |> List.distinct
    
    Namespace(cfg.Namespace) {
        for schema in schemas do
            let tables = 
                filteredTables 
                |> List.filter (fun t -> t.Schema = schema)
                |> List.map (fun t -> t.Name)

            let enums = 
                db.Enums 
                |> List.filter (fun e -> e.Schema = schema)
                |> List.map (fun e -> e.Name)

            NestedModule(schema) {
                for enum in enums do
                    let enumType = 
                        db.Enums 
                        |> List.find (fun e -> e.Schema = schema && e.Name = enum)

                    let labels = 
                        enumType.Labels 
                        |> List.sortBy _.SortOrder
                                            
                    Enum(backticks enum) {
                        for label in labels do
                            EnumCase(backticks label.Name, string label.SortOrder)
                    }

                for table in tables do
                    let tableType = 
                        db.Tables 
                        |> List.find (fun t -> t.Schema = schema && t.Name = table)

                    
                    let tableRecord = 
                        Record(table) {
                        
                            for col in tableType.Columns do 
                                let baseType = 
                                    // Handles array types: "byte[]", "string[]", "int[]", "int []", "int array"
                                    if col.TypeMapping.ClrType.EndsWith "[]" || col.TypeMapping.ClrType.EndsWith "array" then
                                        let baseTypeNm = col.TypeMapping.ClrType.Split([| "[]"; " []"; " array" |], System.StringSplitOptions.RemoveEmptyEntries) |> Array.head
                                        $"{baseTypeNm} []"
                                    else
                                        col.TypeMapping.ClrType

                                let columnPropertyType =
                                    if col.IsNullable then
                                        match cfg.NullablePropertyType with
                                        | NullablePropertyType.Option ->
                                            $"Option<{baseType}>"
                                        | NullablePropertyType.Nullable ->
                                            $"System.Nullable<{baseType}>"
                                    else 
                                        baseType

                                let field = Field(col.Name, columnPropertyType)
                                match col.TypeMapping.ProviderDbType with
                                | Some providerDbType -> 
                                    field.attribute(Attribute($"SqlHydra.ProviderDbType(\"{providerDbType}\")"))
                                | _ -> 
                                    field

                        }

                    if cfg.IsCLIMutable 
                    then tableRecord.attribute(Attribute("CLIMutable"))
                    else tableRecord

                    if cfg.TableDeclarations then
                        Value(table, $"SqlHydra.Query.Table.table<{backticks table}>", false)
            }
    }

open Fantomas
open Fantomas.Core

/// Formats the generated code using Fantomas.
let toFormattedCode (cfg: Config) (app: AppInfo) (version: string) (source: WidgetBuilder<SyntaxOak.Oak>) = 
    let comment = $"// This code was generated by `{app.Name}` -- v{version}."

    //let cfg = 
    //    { FormatConfig.FormatConfig.Default with 
    //        StrictMode = true
    //        MaxIfThenElseShortWidth = 400   // Forces ReadIfNotNull if/then to be on a single line
    //        MaxValueBindingWidth = 400      // Ensure reader property/column bindings stay on one line
    //        MaxLineLength = 400             // Ensure reader property/column bindings stay on one line
    //    }

    let output = 
        source
        |> Gen.mkOak
        |> CodeFormatter.FormatOakAsync
        |> Async.RunSynchronously

    let formattedCodeWithComment =
        [   
            comment
            output
        ]
        |> String.concat System.Environment.NewLine

    formattedCodeWithComment
